/**
 * 	main.cpp
 *
 *  Created on: 15.05.2014
 *      Author: Shcheblykin
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include "inc/dr.h"
#include "inc/bsp.h"

//---МАКРОПОДСТАНОВКИ-----------------------------------------------------------


//-----	Тестовые сигналы
/// Пин подключения отладочного светодиода VD20.
#define LED_VD20 PA0
/// Пин подключения отладочного светодиода VD19.
#define LED_VD19 PA1
/// Пин подключения отладочной тестовой точки TP3.
#define TP3 PA2
/// Пин подключения отладочной тестовой точки TP4.
#define TP4 PA3

//-----	Телемеханика
/// Пин подключения входа Телемеханики.
#define TM_RX PC3
/// Пин подключения выхода Телемеханики.
#define TM_TX PC2

//----- Цифровая ретрансляция
/// Пин подключения входа ЦПП.
#define DR_RX PD2
/// Пин подключения выхода ЦПП.
#define DR_TX PD3
/// Пин управления ЦПП.
#define DR_EN PD4

//----- Связь с БСП
/// Пин подключения входа БСП.
#define BSP_RX PD0
/// Пин подключения выхода БСП.
#define BSP_TX PD1


/// Режимы работы цифрового переприема
enum REG_DR {
	REG_ERROR	= 0,	///< Ошибочное значение
	REG_OFF 	= 1,	///< Выключен.
	REG_RX_KEDR = 2,	///< Приемник КЕДР
	REG_TX_KEDR = 3		///< Передатчик КЕДР
};

//---ОПИСАНИЕ СТРУКТУР----------------------------------------------------------



//---ОБЪЯВЛЕНИЯ ФУНКЦИЙ---------------------------------------------------------


__attribute__((section(".init3")))
void low_level_init()		__attribute__((__naked__));




//---ПЕРЕМЕННЫЕ-----------------------------------------------------------------


TDigitalRetrans dr;	///< Класс работы с ЦПП
TBsp bsp;			///< Класс работы с БСП.


//---ОПРЕДЕЛЕНИЯ ФУНКЦИЙ--------------------------------------------------------


/** Main.
 * 	@return Нет.
 */
__attribute__ ((OS_main)) int main(void) {

	REG_DR regdr = REG_OFF;

	sei();

	while(1) {
		// получена посылка с БСП, надо обработать и ответить
		if (bsp.isNewData()) {

			// смена режима работы ЦПП, если поступили новые данные с БСП
			uint8_t r = bsp.getRegime();
			if (r != 0) {
				if (r == 1) {
					regdr = REG_RX_KEDR;
				} else if (r == 2) {
					regdr = REG_TX_KEDR;
				} else {
					regdr = REG_OFF;
				}
			}

			// подготовка к передаче данных в БСП
			uint8_t error = dr.isFault();
			uint8_t comdr = dr.getCom();

			// ошибка в работе ЦПП 		-> ошибка 2
			if (error)
				error = 2;

			if (regdr == REG_OFF) {
				// если ЦПП не запущен		-> ошибка 1
				error = 1;
				comdr = 0;
			} else if (regdr == REG_RX_KEDR) {
				// в Приемнике КЕДР не может быть команд с ЦПП
				comdr = 0;
			}

			// подготовка и отправка данных в БСП
			bsp.makeTxData(comdr, error);
			while(!(UCSR0A | (1 << UDRE0)));
			UDR0 = bsp.bufTx[0];
			while(!(UCSR0A | (1 << UDRE0)));
			UDR0 = bsp.bufTx[1];
		}

		// установка значения на выходе ТМ
		if (bsp.tmTx) {
			 PORTC = (1 << TM_TX);
		} else {
			PORTC &= ~(1 << TM_TX);
		}

		// считывание значения на входе ТМ
		bsp.tmRx = (PORTC & (1 << TM_RX));
		wdt_reset();
	}
}


/**	Прерывание Таймера 1 по совпадению.
 *
 *	Попадание в прерывание означает, наличие проблем со связью ЦПП. И тут
 *	устанавливается флаг наличия ошибки ЦПП.
 *
 */
ISR(TIMER1_COMPA_vect) {
	dr.decError();
}


/** Прерывание по приему UART0.
 *
 * 	Прием байта данных от БСП.
 */
ISR(USART0_RX_vect) {
	uint8_t status = UCSR0A;
	uint8_t byte = UDR0;

	// Обработка данных принятого байта
	bsp.checkRxProtocol(byte, status & ((1 << FE0) | (1 << DOR0)));
}


/** Прерывание по приему UART1.
 */
ISR(USART1_RX_vect) {
	// регистр состояния
	uint8_t status = UCSR1A;
	// принятый байт данных
	uint8_t byte = UDR1;

	// Обработка принятого байта
	dr.checkByteProtocol(byte, status & ((1 << FE1) | (1 << DOR1)));
}


// Прерывание по окончанию передачи UART1.
ISR(USART1_TX_vect) {

}


// Прерывание по опустошению буфера передачи UART1.
ISR(USART1_UDRE_vect){

}


/**	Инициализация периферии.
 *
 * 	Функция помещается в начальный загрузчик по адресу ".init3".
 * 	@n Неиспользуемые порты по умолчанию настроены на вход с подтяжкой к +.
 */
void low_level_init() {
	// включение сторожевого таймера
	wdt_enable(WDTO_15MS);

	// порт А
	// тестовые выходы
	DDRA = (1 << LED_VD20) | (1 << LED_VD19) | (1 << TP3) | (1 << TP4);
	PORTA = 0x00;

	// порт C
	// телемеханика
	DDRC = (1 << TM_TX) | (0 << TM_RX);
	PORTC = 0x00;

	// PORTD
	// ЦПП + связь с БСП
	DDRD = (1 << DR_TX) | (1 << DR_EN) | (0 << DR_RX);
	DDRD |= (1 << BSP_TX) | (0 << BSP_RX);
	PORTD = 0x00;

	// UART0
	// связь с БСП
	// 38.4бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	// включено прерывание по приему
	UBRR0 = 64;
	UCSR0B = (1 << TXEN0) | (0 << UCSZ02);
	UCSR0A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию
	UCSR0B |=  (1 << RXCIE0);

	// UART1
	// ЦПП
	// 500бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	// прерывания отключены
	UBRR1 = 4;
	UCSR1A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR1B = (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);
	UCSR1C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию
//	UCSR1B = (1 << RXCIE1) | (TXCIE1) | (UDRIE1);

	// Таймер 0
	// режим CTC
	// 1мс при кварце 20МГц:
	// частота = F_CPU / (2 * N * (1 + OCR)
	TCCR0A = (1 << WGM01) | (0 << WGM00);
	TCCR0B = (0 << WGM02);
	// TCCR0B |=

	// Таймер 1
	// режим CTC
	// делитель N = 8, счет до OCR = 6249
	// частота = F_CPU / (2 * N * (1 + OCR)
	// при F_CPU = 20МГц получим 200Гц
	// TCCR1A 	= (0 << WGM11) | (0 << WGM10);	// по умолчанию
	TCCR1B 	= (0 << WGM13) | (1 << WGM12);
	TCCR1C 	= 0;	// по умолчанию
	TCNT1 	= 0;
	OCR1A 	= 6249;
	TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10); // запуск с делителем 8
	TIMSK1 |= (1 << OCIE1A);
}
