/**
 * 	main.cpp
 *
 *  Created on: 15.05.2014
 *      Author: Shcheblykin
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include "inc/dr.h"

//МАКРОПОДСТАНОВКИ--------------------------------------------------------------


//-----	Тестовые сигналы
/// Пин подключения отладочного светодиода VD20.
#define LED_VD20 PA0
/// Пин подключения отладочного светодиода VD19.
#define LED_VD19 PA1
/// Пин подключения отладочной тестовой точки TP3.
#define TP3 PA2
/// Пин подключения отладочной тестовой точки TP4.
#define TP4 PA3

//-----	Телемеханика
/// Пин подключения входа Телемеханики.
#define TM_RX PC3
/// Пин подключения выхода Телемеханики.
#define TM_TX PC2

//----- Цифровая ретрансляция
/// Пин подключения входа ЦПП.
#define DR_RX PD2
/// Пин подключения выхода ЦПП.
#define DR_TX PD3
/// Пин управления ЦПП.
#define DR_EN PD4

//----- Связь с БСП
/// Пин подключения входа БСП.
#define BSP_RX PD0
/// Пин подключения выхода БСП.
#define BSP_TX PD1


/// Размер буфера приема/передачи для связи с БСП.
#define BSP_BUF_MAX 4

//ОПИСАНИЕ СТРУКТУР-------------------------------------------------------------



//ОБЪЯВЛЕНИЯ ФУНКЦИЙ------------------------------------------------------------


__attribute__((section(".init3")))
void low_level_init()		__attribute__((__naked__));


//ПЕРЕМЕННЫЕ--------------------------------------------------------------------


/// Буфер приема/передачи для связи с БСП.
uint8_t bspBuf[BSP_BUF_MAX];
/// Флаг ошибки цифрового переприема.
bool drError = false;
/// Структура параметров ЦПП.
TDigitalRetrans dr;


//ОПРЕДЕЛЕНИЯ ФУНКЦИЙ-----------------------------------------------------------


/** Main.
 * 	@return Нет.
 */
__attribute__ ((OS_main)) int main(void) {

	sei();

	while(1) {

		if (dr.isFault()) {
			// TODO: ЦПП ошибка работы
		}

		wdt_reset();
	}
}


/**	Прерывание Таймера 1 по совпадению.
 *
 *	Попадание в прерывание означает, наличие проблем со связью ЦПП. И тут
 *	устанавливается флаг наличия ошибки ЦПП.
 *
 */
ISR(TIMER1_COMPA_vect) {
	dr.decError();
}


/** Прерывание по приему UART0.
 *
 * 	Прием байта данных от БСП.
 */
ISR(USART0_RX_vect) {
	uint8_t status = UCSR0A;
	uint8_t byte = UDR0;

	// Обработка данных, если ошибок приема нет.
	if ((status & ((1 << FE0) | (1 << DOR0))) == 0) {

	}

}


/// Прерывание по окончанию передачи UART0.
ISR(USART0_TX_vect) {

}


/// Прерывание по опустошению буфера передачи UART0.
ISR(USART0_UDRE_vect){

}

/** Прерывание по приему UART1.
 */
ISR(USART1_RX_vect) {
	// регистр состояния
	uint8_t status = UCSR1A;
	// принятый байт данных
	uint8_t byte = UDR1;

	// Обработка данных, если ошибок приема нет.
	dr.checkByteProtocol(byte, status & ((1 << FE1) | (1 << DOR1)));
}


/// Прерывание по окончанию передачи UART1.
ISR(USART1_TX_vect) {

}


/// Прерывание по опустошению буфера передачи UART1.
ISR(USART1_UDRE_vect){

}


/**	Инициализация периферии.
 *
 * 	Функция помещается в начальный загрузчик по адресу ".init3".
 * 	@n Неиспользуемые порты по умолчанию настроены на вход с подтяжкой к +.
 */
void low_level_init() {
	// включение сторожевого таймера
	wdt_enable(WDTO_15MS);

	// порт А
	// тестовые выходы
	DDRA = (1 << LED_VD20) | (1 << LED_VD19) | (1 << TP3) | (1 << TP4);
	PORTA = 0x00;

	// порт C
	// телемеханика
	DDRC = (1 << TM_TX) | (0 << TM_RX);
	PORTC = 0x00;

	// PORTD
	// ЦПП + связь с БСП
	DDRD = (1 << DR_TX) | (1 << DR_EN) | (0 << DR_RX);
	DDRD |= (1 << BSP_TX) | (0 << BSP_RX);
	PORTD = 0x00;

	// UART0
	// связь с БСП
	// 38.4бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	UBRR0 = 64;
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);
	UCSR0A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию

	// UART1
	// ЦПП
	// 500бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	UBRR0 = 4;
	UCSR0A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию

	// Таймер 0
	// режим CTC
	// 1мс при кварце 20МГц:
	// частота = F_CPU / (2 * N * (1 + OCR)
	TCCR0A = (1 << WGM01) | (0 << WGM00);
	TCCR0B = (0 << WGM02);
	// TCCR0B |=

	// Таймер 1
	// режим CTC
	// делитель N = 8, счет до OCR = 6249
	// частота = F_CPU / (2 * N * (1 + OCR)
	// при F_CPU = 20МГц получим 200Гц
	// TCCR1A 	= (0 << WGM11) | (0 << WGM10);	// по умолчанию
	TCCR1B 	= (0 << WGM13) | (1 << WGM12);
	TCCR1C 	= 0;	// по умолчанию
	TCNT1 	= 0;
	OCR1A 	= 6249;
	TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10); // запуск с делителем 8
	TIMSK1 |= (1 << OCIE1A);

}
