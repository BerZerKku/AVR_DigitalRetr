/**
 * 	main.cpp
 *
 *  Created on: 15.05.2014
 *      Author: Shcheblykin
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/wdt.h>
#include "inc/dr.h"

//МАКРОПОДСТАНОВКИ--------------------------------------------------------------


//-----	Тестовые сигналы
/// Пин подключения отладочного светодиода VD20.
#define LED_VD20 PA0
/// Пин подключения отладочного светодиода VD19.
#define LED_VD19 PA1
/// Пин подключения отладочной тестовой точки TP3.
#define TP3 PA2
/// Пин подключения отладочной тестовой точки TP4.
#define TP4 PA3

//-----	Телемеханика
/// Пин подключения входа Телемеханики.
#define TM_RX PC3
/// Пин подключения выхода Телемеханики.
#define TM_TX PC2

//----- Цифровая ретрансляция
/// Пин подключения входа ЦПП.
#define DR_RX PD2
/// Пин подключения выхода ЦПП.
#define DR_TX PD3
/// Пин управления ЦПП.
#define DR_EN PD4

//----- Связь с БСП
/// Пин подключения входа БСП.
#define BSP_RX PD0
/// Пин подключения выхода БСП.
#define BSP_TX PD1


/// Размер буфера приема/передачи для связи с БСП.
#define BSP_BUF_MAX 4

//ОПИСАНИЕ СТРУКТУР-------------------------------------------------------------



//ОБЪЯВЛЕНИЯ ФУНКЦИЙ------------------------------------------------------------


__attribute__((section(".init3")))
void low_level_init()		__attribute__((__naked__));


//ПЕРЕМЕННЫЕ--------------------------------------------------------------------


/// Буфер приема/передачи для связи с БСП.
uint8_t bspBuf[BSP_BUF_MAX];
/// Флаг ошибки цифрового переприема.
bool drError = false;
/// Структура параметров ЦПП.
TDigitalRetrans dr;


//ОПРЕДЕЛЕНИЯ ФУНКЦИЙ-----------------------------------------------------------


/** Main.
 * 	@return Нет.
 */
__attribute__ ((OS_main)) int main(void) {

	sei();

	while(1) {

		if (dr.isFault()) {
			// TODO: ЦПП ошибка работы
		}

		wdt_reset();
	}
}


/**	Прерывание Таймера 1 по совпадению.
 *
 *	Попадание в прерывание означает, наличие проблем со связью ЦПП. И тут
 *	устанавливается флаг наличия ошибки ЦПП.
 *
 */
ISR(TIMER1_COMPA_vect) {
	dr.decError();
}


/** Прерывание по приему UART0.
 *
 * 	Прием байта данных от БСП.
 */
ISR(USART0_RX_vect) {
	uint8_t status = UCSR0A;
	uint8_t byte = UDR0;

	// Обработка данных, если ошибок приема нет.
	if ((status & ((1 << FE0) | (1 << DOR0))) == 0) {

	}

}


/// Прерывание по окончанию передачи UART0.
ISR(USART0_TX_vect) {

}


/// Прерывание по опустошению буфера передачи UART0.
ISR(USART0_UDRE_vect){

}

/** Прерывание по приему UART1.
 *
 * 	Прием данных по цифровому переприему и проверка по протоколу КЕДР:
 *	-# 	@b 0хАА - первый синхробайт
 *	-# 	@b 0хАА - второй синхробайт
 *	@n	v Прямой байт = ~инверсный (bx = ~ix).
 *	-# 	@b b1 - прямоой байт, 		команды 1..8
 *	-# 	@b i1 - инверсный байт, 	команды 1..8
 *	-#  @b b2 - прямоой байт, 		команды 9..16
 *	-#  @b i2 - инверсный байт,	команды 9..16
 *	-#  @b b3 - прямоой байт, 		команды 17..24
 *	-#  @b i3 - инверсный байт,	команды 17..24
 *	-#	@b b4 - прямоой байт, 		команды 25..32
 *	-#	@b i4 - инверсный байт, 	команды 25..32
 *	@n	v Байты зарезервированные на будущее.
 *	-# 	@b 0x00 - резерв
 *	-# 	@b 0x00 - резерв
 *	-# 	@b 0x00 - резерв
 *	-# 	@b 0x00 - резерв
 *	-# 	@b 0x00 - резерв
 *	@n v Т.к. синхробайты не учитываются, а резервные байты всегда 0. То сумма
 *	@n v в итоге складывается из байт команд (прямой + инверсный),
 *	@n v т.е. контрольная сумма всегда  = LOW(0xFF + 0xFF + 0xFF + 0xFF) = 0xFC.
 *	-#	@b crc - контрольная сумма, равная младшему байту суммы всех данных,
 *	за исключением синхробайт.
 */
ISR(USART1_RX_vect) {
	// максимальное кол-во байт в послыке, используется для установки ошибки
	static const uint8_t MAX_STEP = 16;
	// текущее положение в протоколе
	static uint8_t step = 0;
	// регистр состояния
	uint8_t status = UCSR1A;
	// принятый байт данных
	uint8_t byte = UDR1;

	dr.buf[step] = byte;
	// Обработка данных, если ошибок приема нет.
	if ((status & ((1 << FE1) | (1 << DOR1))) == 0) {
		// проверка полученного байта по протоколу
		if (step <= 1) {
			// два синхробайта АА
			step = (byte == 0xAA) ? step + 1 : 0;
		} else if (step <=9) {
			// 4 прямой + инверсный байта команд
			// прямой байт записывается в буфер
			// инверсный сравнивается с ним
			if ((step % 2) == 0) {
				step++;
			} else {
				if ((byte ^ dr.buf[step - 1]) == 0xFF) {
					dr.buf[step++] = byte;
				} else {
					// ошибка, прямой байт команды не равен инверсному
					step = MAX_STEP;
				}
			}
		} else if (step <= 14) {
			// 5 резервных байт данных
			// crc не участвует, т.к. данных нет
			// ошибка, если резервный байт не равен 0
			step = (byte == 0) ? step + 1 : MAX_STEP;
		} else if (step == 15) {
			// проверка контрольной суммы
			if (byte == 0xFC) {
				if (!dr.isWarning()) {
					// сообщение принято
					dr.checkCommand();
				}
			} else {
				// ошибка, не сошлись контрольные суммы
				step = MAX_STEP;
			}
		}
	} else {
		// ошибка приема по UART
		step = MAX_STEP;
	}

	if (step >= MAX_STEP) {
		step = 0;
		dr.setError();
	}
}


/// Прерывание по окончанию передачи UART1.
ISR(USART1_TX_vect) {

}


/// Прерывание по опустошению буфера передачи UART1.
ISR(USART1_UDRE_vect){

}


/**	Инициализация периферии.
 *
 * 	Функция помещается в начальный загрузчик по адресу ".init3".
 * 	@n Неиспользуемые порты по умолчанию настроены на вход с подтяжкой к +.
 */
void low_level_init() {
	// включение сторожевого таймера
	wdt_enable(WDTO_15MS);

	// порт А
	// тестовые выходы
	DDRA = (1 << LED_VD20) | (1 << LED_VD19) | (1 << TP3) | (1 << TP4);
	PORTA = 0x00;

	// порт C
	// телемеханика
	DDRC = (1 << TM_TX) | (0 << TM_RX);
	PORTC = 0x00;

	// PORTD
	// ЦПП + связь с БСП
	DDRD = (1 << DR_TX) | (1 << DR_EN) | (0 << DR_RX);
	DDRD |= (1 << BSP_TX) | (0 << BSP_RX);
	PORTD = 0x00;

	// UART0
	// связь с БСП
	// 38.4бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	UBRR0 = 64;
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);
	UCSR0A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию

	// UART1
	// ЦПП
	// 500бит/с при кварце 20Мгц
	// включено удвоение скорости работы
	// 1 стоп бит, 8 бит данных, контроль четности отключен
	UBRR0 = 4;
	UCSR0A = (1 << U2X0) | (1 << UCSZ01) | (1 << UCSZ00);
	UCSR0B = (1 << RXEN0) | (1 << TXEN0) | (0 << UCSZ02);
	UCSR0C = (1 << UCSZ00) | (1 << UCSZ10);	//  по умолчанию

	// Таймер 0
	// режим CTC
	// 1мс при кварце 20МГц:
	// частота = F_CPU / (2 * N * (1 + OCR)
	TCCR0A = (1 << WGM01) | (0 << WGM00);
	TCCR0B = (0 << WGM02);
	// TCCR0B |=

	// Таймер 1
	// режим CTC
	// делитель N = 8, счет до OCR = 6249
	// частота = F_CPU / (2 * N * (1 + OCR)
	// при F_CPU = 20МГц получим 200Гц
	// TCCR1A 	= (0 << WGM11) | (0 << WGM10);	// по умолчанию
	TCCR1B 	= (0 << WGM13) | (1 << WGM12);
	TCCR1C 	= 0;	// по умолчанию
	TCNT1 	= 0;
	OCR1A 	= 6249;
	TCCR1B |= (1 << CS12) | (0 << CS11) | (0 << CS10); // запуск с делителем 8
	TIMSK1 |= (1 << OCIE1A);

}
