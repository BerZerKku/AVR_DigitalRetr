/*
 * dr.h
 *
 *  Created on: 19.05.2014
 *      Author: Shcheblykin
 */

/// Класс работы с ЦПП.
/** При обнаружении любой ошибки в принятых пакетах ЦПП к счетчику ошибок
 * 	добавляется значение \a CNT_ERROR. Cодержимое данного счетчика
 * 	соответствует кол-ву времени в мс, на которое блокируется работа ЦПП.
 * 	Если значение \a error превысило порог \a ERRORS_TO_FAULT, то считаем
 * 	что работа ЦПП невозможна. Максимально возможное значение ошибки может быть
 * 	\a MAX_ERRORS.
 * 	@see CNT_ERROR
 * 	@see ERRORS_TO_FAULT
 * 	@see MAX_ERRORS
 */



#ifdef  AVR
	#define INLINE __attribute__((always_inline))
#else
	#define INLINE inline
#endif

class TDigitalRetrans {

protected:
	/// Размер буфера приема/передачи для цифрового переприема.
	const static uint8_t BUF_MAX = 20;
	/// максимальное кол-во байт в послыке протокола КЕДР
	const static uint8_t MAX_STEP = 16;
	/// Кол-во накопленных ошибок для перехода из предупреждения в аварию
	const static uint8_t ERRORS_TO_FAULT = 100;
	/// Максимальное кол-во ошибок
	const static uint8_t MAX_ERRORS = 200;
	/// Кол-во мс добавляемых при определении ошибки
	const static uint8_t CNT_ERROR = 5;

	uint8_t mCodeToCom[256];		///< Таблица код ЦПП -> команда
	uint8_t error;					///< Флаг ошибки ЦПП.
	uint8_t com;					///< Команда на приеме/передаче.
	uint8_t cntCom;					///< Кол-во принятых(переданных) посылок.

	// для обработки по протоколу
	uint8_t step;

	/**	Заполнение таблицы сответствия номера команды и кода ЦПП.
	 *
	 *	Используется для уменьшения времени преобразования код <-> команда.
	 *	Где номеру команды соответствует номер установленного бита.
	 */
	void createTableCodeToCom() {
		mCodeToCom[0] = 0;
		// заполнение массива значениями 0xFF, т.е. ошибкой
		for (uint16_t i = 1, temp = 0x01; i < 256; i++) {
			mCodeToCom[i] = 0xFF;
			temp  = (temp & 0x80) ? 0x01 : temp << 1;
		}
		// заполнение массива нужными значениями
		// т.е. массив[код команды ЦПП] = номер команды
		for(uint8_t i = 0; i < 8; i++) {
			mCodeToCom[(1 << i)] = i + 1;
		}
	}

	uint8_t buf[BUF_MAX];			///< Буфер приема/передачи.

public:
	/**	Конструктор.
	 *
	 * 	Устанавливаем кол-во ошибок \a CNT_ERROR.
	 * 	@see CNT_ERROR
	 */
	TDigitalRetrans() {
		error = CNT_ERROR;
		com = 0;
		cntCom = 0;
		step = 0;
		buf[0] = 0xAA;
		buf[1] = 0xAA;

		createTableCodeToCom();
	}

	/**	Проверка наличия ошибок в принятых пакетах ЦПП.
	 * 	@retval True - есть ошибки.
	 * 	@retval False - ошибок нет.
	 */
	INLINE bool isWarning() const {
		return (error > 0);
	 }


	/**	Проверка наличия ошибки в работе ЦПП.
	 *
	 * 	Устанавливается, если ошибок в принятых пакетах накопилось слишком
	 * 	много. А точнее >= \a ERRORS_TO_FAULT.
	 * 	@see ERRORS_TO_FAULT
	 * 	@retval True - есть ошибка.
	 * 	@retval False - ошибок нет.
	 */
	INLINE bool isFault() const {
		return (error >= ERRORS_TO_FAULT);
	}

	/** Установка наличия ошибки в принятых пакетах ЦПП.
	 *
	 * 	Если значение счетчика ошибок не превышает \a MAX_ERROR, к счетчику
	 * 	добавляется \a CNT_ERROR ошибок.
	 * 	@see MAX_ERRORS
	 * 	@see CNT_ERROR
	 */
	INLINE void setError() {
		if (error < MAX_ERRORS)
			error += CNT_ERROR;
	}

	/** Уменьшение кол-ва ошибок в принятых пакетах ЦПП.
	 *
	 * 	Если значение счетчика больше нуля, то оно уменьшается на единицу.
	 */
	INLINE void decError() {
		if (error > 0)
			error--;
	}

	/** Сбрасывает кол-во ошибок в принятых пакетах ЦПП.
	 *
	 */
	INLINE void clrError() {
		error = 0;
	}

	/**	Проверка наличия команды в принятом пакете ЦПП.
	 *
	 * 	Проверяются прямые байты команд на наличие в них команды. В пакете
	 * 	должно быть не более одной команды.
	 */
	INLINE void checkCommand() {
		uint8_t com = 0;

		for (unsigned char i = 2, tCom = 0; i < 10; i += 2, tCom += 8) {
			uint8_t temp = mCodeToCom[buf[i]];
			// если число не подходящее - вернуть ошибочный код
			if (temp > 8) {
				// в текущем байте обнаружено более одной команды
				com = 0xFF;
				break;
			} else if (temp != 0) {
				if (com == 0) {
					com = tCom + temp;
				} else {
					// в посылке обнаружено более одной команды
					com = 0xFF;
					break;
				}
			}
		}

		if (com > 32) {
			// ошибка данных в принятом пакете ЦПП
			setError();
		} else {
			// принята команда
			if (this->com == com) {
				// увеличение счетчика повторно принятых посылок с этой командой
				this->cntCom = (this->cntCom < 3) ? this->cntCom + 1 : 3;
			} else {
				// принята новая команда
				this->com = com;
				this->cntCom = 1;
			}
		}
	}

	/**	Сброс в 0 обработчика принятых данных.
	 *
	 *	Вызывается в случае необходимости начать проверку принятых данных
	 *	начиная с поиска синхробайт.
	 *	Необходимо например в случае ошибок в работе UART.
	 */
	INLINE void clrProtocol() {
		step = 0;
	}

	/**	Проверка принятого байта данных на соответствие протоколу.
	 *
	 *	Если установлен флаг наличия ошибки в \a status, протокол
	 *	сбрасывается и начинается поиск новой посылки. В случае обнаружения
	 *	ошибки в самом протоколе, также происходит сброс протокола.
	 *
	 *	Если пакет принят полностью и ошибок нет, вызывается функция поиска
	 *	команды в принятых данных.
	 *
	 * 	Протокол КЕДР:
	 *	-# 	@b 0хАА - первый синхробайт
	 *	-# 	@b 0хАА - второй синхробайт
	 *	@n	v Прямой байт = ~инверсный (bx = ~ix).
	 *	-# 	@b b1 - прямоой байт, 		команды 1..8
	 *	-# 	@b i1 - инверсный байт, 	команды 1..8
	 *	-#  @b b2 - прямоой байт, 		команды 9..16
	 *	-#  @b i2 - инверсный байт,	команды 9..16
	 *	-#  @b b3 - прямоой байт, 		команды 17..24
	 *	-#  @b i3 - инверсный байт,	команды 17..24
	 *	-#	@b b4 - прямоой байт, 		команды 25..32
	 *	-#	@b i4 - инверсный байт, 	команды 25..32
	 *	@n	v Байты зарезервированные на будущее.
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	@n v Т.к. синхробайты не учитываются, а резервные байты всегда 0.
	 *	@n v То сумма в итоге складывается из байт команд (прямой + инверсный),
	 *	@n v т.е. контрольная сумма всегда  = LOW(0xFF+0xFF+0xFF+0xFF) = 0xFC.
	 *	-#	@b crc - контрольная сумма, равная младшему байту суммы всех данных,
	 *	за исключением синхробайт.
	 *
	 *	@param byte Байт данных.
	 *	@param status Статус источника данных, True - ошибка.
	 */
	INLINE void checkByteProtocol(uint8_t byte, bool status) {
		// проверка полученного байта по протоколу
		if (status) {
			step = MAX_STEP;
		} else {
			buf[step] = byte;
			if (step <= 1) {
				// два синхробайта АА
				step = (byte == 0xAA) ? step + 1 : 0;
			} else if (step <= 9) {
				// 4 прямой + инверсный байта команд
				// прямой байт записывается в буфер
				// инверсный сравнивается с ним
				if ((step % 2) == 0) {
					step++;
				} else {
					if ((byte ^ buf[step - 1]) == 0xFF) {
						buf[step++] = byte;
					} else {
						// ошибка, прямой байт команды не равен инверсному
						step = MAX_STEP;
					}
				}
			} else if (step <= 14) {
				// 5 резервных байт данных
				// crc не считаем т.к. должны быть равны 0
				step = (byte == 0) ? step + 1 : MAX_STEP;
			} else if (step == 15) {
				// проверка контрольной суммы
				if (byte == 0xFC) {
					if (!isWarning()) {
						// сообщение принято
						checkCommand();
					}
				}
				step = MAX_STEP;
			}
		}

		// в случае ошибки обработки протокола
		// возвращаемся к поиску синхробайт и устанавливаем ошибку
		if (step >= MAX_STEP) {
			step = 0;
			setError();
		}
	}
};

