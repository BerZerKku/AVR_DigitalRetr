/*
 * dr.h
 *
 *  Created on: 19.05.2014
 *      Author: Shcheblykin
 */

/// Класс работы с ЦПП.
/** При обнаружении любой ошибки в принятых пакетах ЦПП к счетчику ошибок
 * 	добавляется значение \a CNT_ERROR. Cодержимое данного счетчика
 * 	соответствует кол-ву времени в мс, на которое блокируется работа ЦПП.
 * 	Если значение \a error превысило порог \a ERRORS_TO_FAULT, то считаем
 * 	что работа ЦПП невозможна. Максимально возможное значение ошибки может быть
 * 	\a MAX_ERRORS.
 * 	@see CNT_ERROR
 * 	@see ERRORS_TO_FAULT
 * 	@see MAX_ERRORS
 */
#ifndef __DR_H_
#define __DR_H_

#include <stdint.h>

#define INLINE __attribute__((always_inline))

class TDigitalRetrans {
protected:
    /// Размер буфера приема/передачи для цифрового переприема.
    const static uint8_t BUF_MAX = 20;
    /// Максимальное кол-во байт в послыке протокола КЕДР.
    const static uint8_t MAX_STEP = 16;
    /// Кол-во накопленных ошибок для перехода из предупреждения в аварию.
    const static uint8_t ERRORS_TO_FAULT = 100;
    /// Максимальное кол-во ошибок
    const static uint8_t MAX_ERRORS = 200;
    /// Кол-во мс добавляемых при определении ошибки.
    const static uint8_t CNT_ERROR = 5;
    /// Кол-во последовательных посылок, необходимое для достоверной команды.
    const static uint8_t CNT_COM = 3;

    bool connect; ///< Флаг наличия связи по ЦПП.

    // переменные необходимые для приема
    uint8_t mCodeToCom[256]; ///< Таблица код ЦПП -> команда.
    uint8_t error; ///< Флаг ошибки ЦПП.
    uint8_t comRx; ///< Команда считанная по ЦПП.
    uint8_t oldCom; ///< Команда в последней посылке.
    uint8_t cntCom; ///< Кол-во принятых(переданных) посылок.
    uint8_t stepRx; ///< Текущий шаг приема по протоколу.

    // переменные необходимые для передачи
    uint8_t comTx; ///< Команда передваемая по ЦПП.
    uint8_t stepTx; ///< Текущий шаг передачи по протоколу.

    /**	Заполнение таблицы сответствия номера команды и кода ЦПП.
     *
     *	Используется для уменьшения времени преобразования код <-> команда.
     *	Где номеру команды соответствует номер установленного бита.
     */
    void createTableCodeToCom() {
        mCodeToCom[0] = 0;
        // заполнение массива значениями 0xFF, т.е. ошибкой
        for (uint16_t i = 1, temp = 0x01; i < 256; i++) {
            mCodeToCom[i] = 0xFF;
            temp = (temp & 0x80) ? 0x01 : temp << 1;
        }
        // заполнение массива нужными значениями
        // т.е. массив[код команды ЦПП] = номер команды
        for (uint8_t i = 0; i < 8; i++) {
            mCodeToCom[(1 << i)] = i + 1;
        }
    }

    uint8_t bufRx[BUF_MAX]; ///< Буфер приемника.
    uint8_t bufTx[BUF_MAX]; ///< Буфер передатчика.

public:

    /**	Конструктор.
     *
     * 	Устанавливаем кол-во ошибок \a CNT_ERROR.
     * 	@see CNT_ERROR
     */
    TDigitalRetrans() {
        connect = false;
        error = CNT_ERROR;
        comRx = 0;
        cntCom = 0;
        stepRx = 0;
        bufRx[0] = 0xAA;
        bufRx[1] = 0xAA;

        createTableCodeToCom();
    }

    /**	Проверка наличия связи по ЦПП в текущий момент.
     *
     * 	Флаг устанавливается после обнаружения синхробайт и приеме первого
     * 	байта команд.
     * 	При считываниии флаг сбрасывается. Так что период считывания надо
     * 	подобрать так, чтобы он успевал устанавливаться при приеме следующей
     * 	посылки.
     *
     * 	@retval True - связь по ЦПП есть.
     * 	@retval False - полных посылок небыло.
     */
    INLINE bool isConnect() {
        bool t = connect;
        connect = false;
        return t;
    }

    /**	Проверка наличия ошибок в принятых пакетах ЦПП.
     * 	@retval True - есть ошибки.
     * 	@retval False - ошибок нет.
     */
    INLINE bool isWarning() const {
        return (error > 0);
    }

    /**	Проверка наличия ошибки в работе ЦПП.
     *
     * 	Устанавливается, если ошибок в принятых пакетах накопилось слишком
     * 	много. А точнее >= \a ERRORS_TO_FAULT.
     * 	@see ERRORS_TO_FAULT
     * 	@retval True - есть ошибка.
     * 	@retval False - ошибок нет.
     */
    INLINE bool isFault() const {
        return (error >= ERRORS_TO_FAULT);
    }

    /** Установка наличия ошибки в принятых пакетах ЦПП.
     *
     * 	Если значение счетчика ошибок не превышает \a MAX_ERROR, к счетчику
     * 	добавляется \a CNT_ERROR ошибок. При этом сбрасывается счетчик принятых
     * 	команд и предыдущая команда.
     * 	@see MAX_ERRORS
     * 	@see CNT_ERROR
     */
    INLINE void setError() {
        if (error < MAX_ERRORS) {
            error += CNT_ERROR;
        }
        cntCom = 0;
        oldCom = 0;
    }

    /** Уменьшение кол-ва ошибок в принятых пакетах ЦПП.
     *
     * 	Если значение счетчика больше нуля, то оно уменьшается на единицу.
     */
    INLINE void decError() {
        if (error > 1) {
            error--;
        }
    }

    /** Сбрасывает кол-во ошибок в принятых пакетах ЦПП.
     *
     */
    INLINE void clrError() {
        error = 0;
    }

    /**	Возвращает номер принятой команды.
     *
     * 	Номер команды может быть от 0 до 32.
     * 	При вызове номер команды сбрасывается в 0.
     *
     * 	@return Номер команды [0, 32].
     */
    INLINE uint8_t getCom() {
        uint8_t t = comRx;
        comRx = 0;
        return t;
    }

    /**	Проверка наличия команды в принятом пакете ЦПП.
     *
     * 	Проверяются прямые байты команд на наличие в них команды. В пакете
     * 	должно быть не более одной команды.
     */
    INLINE void checkCommand() {
        uint8_t newcom = 0;

        for (unsigned char i = 2, tCom = 0; i < 10; i += 2, tCom += 8) {
            uint8_t temp = mCodeToCom[bufRx[i]];
            // если число не подходящее - вернуть ошибочный код
            if (temp > 8) {
                // в текущем байте обнаружено более одной команды
                newcom = 0xFF;
                break;
            } else if (temp != 0) {
                if (newcom == 0) {
                    newcom = tCom + temp;
                } else {
                    // в посылке обнаружено более одной команды
                    newcom = 0xFF;
                    break;
                }
            }
        }

        if (newcom > 32) {
            // ошибка данных в принятом пакете ЦПП
            setError();
        }

        if (!isWarning()) {
            // принята команда при отсутствии проблем со связью
            if (oldCom == newcom) {
                // увеличение счетчика повторно принятых посылок с этой командой
                // при достижении CNT_COM формируется наличие команды
                // дальше счетчик останавливается
                if (cntCom <= CNT_COM) {
                    cntCom++;
                    if (cntCom == CNT_COM) {
                        this->comRx = newcom;
                    }
                }
            } else {
                // принята новая команда
                oldCom = newcom;
                cntCom = 1;
            }
        }
    }

    /**	Проверка принятого байта данных на соответствие протоколу.
     *
     *	Если установлен флаг наличия ошибки в \a status, протокол
     *	сбрасывается и начинается поиск новой посылки. В случае обнаружения
     *	ошибки в самом протоколе, также происходит сброс протокола.
     *
     *	Если пакет принят полностью и ошибок нет, вызывается функция поиска
     *	команды в принятых данных.
     *
     * 	Протокол КЕДР:
     *	-# 	@b 0хАА - первый синхробайт
     *	-# 	@b 0хАА - второй синхробайт
     *	@n	v Прямой байт = ~инверсный (bx = ~ix).
     *	-# 	@b b1 - прямоой байт, 		команды 1..8
     *	-# 	@b i1 - инверсный байт, 	команды 1..8
     *	-#  @b b2 - прямоой байт, 		команды 9..16
     *	-#  @b i2 - инверсный байт,		команды 9..16
     *	-#  @b b3 - прямоой байт, 		команды 17..24
     *	-#  @b i3 - инверсный байт,		команды 17..24
     *	-#	@b b4 - прямоой байт, 		команды 25..32
     *	-#	@b i4 - инверсный байт, 	команды 25..32
     *	@n	v Байты зарезервированные на будущее.
     *	-# 	@b 0x00 - резерв
     *	-# 	@b 0x00 - резерв
     *	-# 	@b 0x00 - резерв
     *	-# 	@b 0x00 - резерв
     *	-# 	@b 0x00 - резерв
     *	@n v Т.к. синхробайты не учитываются, а резервные байты всегда 0.
     *	@n v То сумма в итоге складывается из байт команд (прямой + инверсный),
     *	@n v т.е. контрольная сумма всегда  = LOW(0xFF+0xFF+0xFF+0xFF) = 0xFC.
     *	-#	@b crc - контрольная сумма, равная младшему байту суммы всех данных,
     *	за исключением синхробайт.
     *
     *	@param byte Байт данных.
     *	@param status Статус источника данных, True - ошибка.
     */
    INLINE void checkByteProtocol(uint8_t byte, bool status) {
        // проверка полученного байта по протоколу
        if (status) {
            stepRx = MAX_STEP;
        } else {
            bufRx[stepRx] = byte;

            if (stepRx == 0) {
                // первый синхробайт 0хAA
                if (byte == 0xAA) {
                    stepRx = 1;
                }
            } else if (stepRx == 1) {
                // второй синхробайт 0хАА
                // при этом устанавливается флаг наличия связи
                if (byte == 0xAA) {
                    stepRx = 2;
                    connect = true;
                } else {
                    stepRx = 0;
                }
            } else if (stepRx <= 9) {
                // 4 прямой + инверсный байта команд
                // прямой байт записывается в буфер
                // инверсный сравнивается с ним
                if ((stepRx % 2) == 0) {
                    stepRx++;
                } else {
                    if ((byte ^ bufRx[stepRx - 1]) == 0xFF) {
                        bufRx[stepRx++] = byte;
                    } else {
                        // ошибка, прямой байт команды не равен инверсному
                        stepRx = MAX_STEP;
                    }
                }
            } else if (stepRx <= 14) {
                // 5 резервных байт данных
                // crc не считаем т.к. должны быть равны 0
                stepRx = (byte == 0) ? stepRx + 1 : MAX_STEP;
            } else if (stepRx == 15) {
                // проверка контрольной суммы
                if (byte == 0xFC) {
                    stepRx = 0;
                    checkCommand();
                } else {
                    // ошибка контрольной суммы
                    stepRx = MAX_STEP;
                }
            }
        }

        // в случае ошибки обработки протокола
        // возвращаемся к поиску синхробайт и устанавливаем ошибку
        if (stepRx >= MAX_STEP) {
            stepRx = 0;
            setError();
        }
    }
};

#endif /* __DR_H_ */
