/*
 * dr.h
 *
 *  Created on: 19.05.2014
 *      Author: Shcheblykin
 */

/// Класс работы с ЦПП.
/** При обнаружении любой ошибки в принятых пакетах ЦПП к счетчику ошибок
 * 	добавляется значение \a CNT_ERROR. Cодержимое данного счетчика
 * 	соответствует кол-ву времени в мс, на которое блокируется работа ЦПП.
 * 	Если значение \a error превысило порог \a ERRORS_TO_FAULT, то считаем
 * 	что работа ЦПП невозможна. Максимально возможное значение ошибки может быть
 * 	\a MAX_ERRORS.
 * 	@see CNT_ERROR
 * 	@see ERRORS_TO_FAULT
 * 	@see MAX_ERRORS
 */
#ifndef __DR_H_
#define __DR_H_

#define INLINE __attribute__((always_inline))

class TDigitalRetrans {

protected:
	/// Размер буфера приема/передачи для цифрового переприема.
	const static uint8_t BUF_MAX = 20;
	/// Максимальное кол-во байт в послыке протокола КЕДР.
	const static uint8_t MAX_STEP = 16;
	/// Кол-во накопленных ошибок для перехода из предупреждения в аварию.
	const static uint8_t ERRORS_TO_FAULT = 100;
	/// Максимальное кол-во ошибок
	const static uint8_t MAX_ERRORS = 200;
	/// Кол-во мс добавляемых при определении ошибки.
	const static uint8_t CNT_ERROR = 5;
	/// Кол-во последовательных посылок, необходимое для достоверной команды.
	const static uint8_t CNT_COM = 3;

	bool	connect;				///< Флаг наличия связи по ЦПП.

	// переменные необходимые для приема
	uint8_t mCodeToCom[256];		///< Таблица код ЦПП -> команда.
	uint8_t error;					///< Флаг ошибки ЦПП.
	uint8_t comRx;					///< Команда считанная по ЦПП.
	uint8_t oldCom;					///< Команда в последней посылке.
	uint8_t cntCom;					///< Кол-во принятых(переданных) посылок.
	uint8_t stepRx;					///< Текущий шаг приема по протоколу.

	// переменные необходимые для передачи
	uint8_t comTx;					///< Команда передваемая по ЦПП.
	uint8_t stepTx;					///< Текущий шаг передачи по протоколу.

	/**	Заполнение таблицы сответствия номера команды и кода ЦПП.
	 *
	 *	Используется для уменьшения времени преобразования код <-> команда.
	 *	Где номеру команды соответствует номер установленного бита.
	 */
	void createTableCodeToCom() {
		mCodeToCom[0] = 0;
		// заполнение массива значениями 0xFF, т.е. ошибкой
		for (uint16_t i = 1, temp = 0x01; i < 256; i++) {
			mCodeToCom[i] = 0xFF;
			temp  = (temp & 0x80) ? 0x01 : temp << 1;
		}
		// заполнение массива нужными значениями
		// т.е. массив[код команды ЦПП] = номер команды
		for(uint8_t i = 0; i < 8; i++) {
			mCodeToCom[(1 << i)] = i + 1;
		}
	}

	uint8_t bufRx[BUF_MAX];			///< Буфер приемника.
	uint8_t bufTx[BUF_MAX];			///< Буфер передатчика.

public:
	/**	Конструктор.
	 *
	 * 	Устанавливаем кол-во ошибок \a CNT_ERROR.
	 * 	@see CNT_ERROR
	 */
	TDigitalRetrans() {
		connect = false;
		error = CNT_ERROR;
		comRx = 0;
		cntCom = 0;
		stepRx = 0;
		bufRx[0] = 0xAA;
		bufRx[1] = 0xAA;

		createTableCodeToCom();
	}

	/**	Проверка наличия связи по ЦПП в текущий момент.
	 *
	 * 	Флаг устанавливается после обнаружения синхробайт и приеме первого
	 * 	байта команд.
	 * 	При считываниии флаг сбрасывается. Так что период считывания надо
	 * 	подобрать так, чтобы он успевал устанавливаться при приеме следующей
	 * 	посылки.
	 *
	 * 	@retval True - связь по ЦПП есть.
	 * 	@retval False - полных посылок небыло.
	 */
	INLINE bool isConnect() {
		bool t = connect;
		connect = false;
		return t;
	}

	/**	Проверка наличия ошибок в принятых пакетах ЦПП.
	 * 	@retval True - есть ошибки.
	 * 	@retval False - ошибок нет.
	 */
	INLINE bool isWarning() const {
		return (error > 0);
	 }


	/**	Проверка наличия ошибки в работе ЦПП.
	 *
	 * 	Устанавливается, если ошибок в принятых пакетах накопилось слишком
	 * 	много. А точнее >= \a ERRORS_TO_FAULT.
	 * 	@see ERRORS_TO_FAULT
	 * 	@retval True - есть ошибка.
	 * 	@retval False - ошибок нет.
	 */
	INLINE bool isFault() const {
		return (error >= ERRORS_TO_FAULT);
	}

	/** Установка наличия ошибки в принятых пакетах ЦПП.
	 *
	 * 	Если значение счетчика ошибок не превышает \a MAX_ERROR, к счетчику
	 * 	добавляется \a CNT_ERROR ошибок. При этом сбрасывается счетчик принятых
	 * 	команд и предыдущая команда.
	 * 	@see MAX_ERRORS
	 * 	@see CNT_ERROR
	 */
	INLINE void setError() {
		if (error < MAX_ERRORS) {
			error += CNT_ERROR;
		}
		cntCom = 0;
		oldCom = 0;
	}

	/** Уменьшение кол-ва ошибок в принятых пакетах ЦПП.
	 *
	 * 	Если значение счетчика больше нуля, то оно уменьшается на единицу.
	 */
	INLINE void decError() {
		if (error > 1) {
			error--;
		}
	}

	/** Сбрасывает кол-во ошибок в принятых пакетах ЦПП.
	 *
	 */
	INLINE void clrError() {
		error = 0;
	}

	/**	Возвращает номер принятой команды.
	 *
	 * 	Номер команды может быть от 0 до 32.
	 * 	При вызове номер команды сбрасывается в 0.
	 *
	 * 	@return Номер команды [0, 32].
	 */
	INLINE uint8_t getCom() {
		uint8_t t = comRx;
		comRx = 0;
		return t;
	}

	/**	Проверка наличия команды в принятом пакете ЦПП.
	 *
	 * 	Проверяются прямые байты команд на наличие в них команды. В пакете
	 * 	должно быть не более одной команды.
	 */
	INLINE void checkCommand() {
		uint8_t newcom = 0;

		for (unsigned char i = 2, tCom = 0; i < 10; i += 2, tCom += 8) {
			uint8_t temp = mCodeToCom[bufRx[i]];
			// если число не подходящее - вернуть ошибочный код
			if (temp > 8) {
				// в текущем байте обнаружено более одной команды
				newcom= 0xFF;
				break;
			} else if (temp != 0) {
				if (newcom == 0) {
					newcom = tCom + temp;
				} else {
					// в посылке обнаружено более одной команды
					newcom = 0xFF;
					break;
				}
			}
		}

		if (newcom > 32) {
			// ошибка данных в принятом пакете ЦПП
			setError();
		}

		if (!isWarning()) {
			// принята команда при отсутствии проблем со связью
			if (oldCom == newcom) {
				// увеличение счетчика повторно принятых посылок с этой командой
				// при достижении CNT_COM формируется наличие команды
				// дальше счетчик останавливается
				if (cntCom <= CNT_COM) {
					cntCom++;
					if (cntCom == CNT_COM) {
						this->comRx = newcom;
					}
				}
			} else {
				// принята новая команда
				oldCom = newcom;
				cntCom = 1;
			}
		}
	}

	/**	Проверка принятого байта данных на соответствие протоколу.
	 *
	 *	Если установлен флаг наличия ошибки в \a status, протокол
	 *	сбрасывается и начинается поиск новой посылки. В случае обнаружения
	 *	ошибки в самом протоколе, также происходит сброс протокола.
	 *
	 *	Если пакет принят полностью и ошибок нет, вызывается функция поиска
	 *	команды в принятых данных.
	 *
	 * 	Протокол КЕДР:
	 *	-# 	@b 0хАА - первый синхробайт
	 *	-# 	@b 0хАА - второй синхробайт
	 *	@n	v Прямой байт = ~инверсный (bx = ~ix).
	 *	-# 	@b b1 - прямоой байт, 		команды 1..8
	 *	-# 	@b i1 - инверсный байт, 	команды 1..8
	 *	-#  @b b2 - прямоой байт, 		команды 9..16
	 *	-#  @b i2 - инверсный байт,		команды 9..16
	 *	-#  @b b3 - прямоой байт, 		команды 17..24
	 *	-#  @b i3 - инверсный байт,		команды 17..24
	 *	-#	@b b4 - прямоой байт, 		команды 25..32
	 *	-#	@b i4 - инверсный байт, 	команды 25..32
	 *	@n	v Байты зарезервированные на будущее.
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	-# 	@b 0x00 - резерв
	 *	@n v Т.к. синхробайты не учитываются, а резервные байты всегда 0.
	 *	@n v То сумма в итоге складывается из байт команд (прямой + инверсный),
	 *	@n v т.е. контрольная сумма всегда  = LOW(0xFF+0xFF+0xFF+0xFF) = 0xFC.
	 *	-#	@b crc - контрольная сумма, равная младшему байту суммы всех данных,
	 *	за исключением синхробайт.
	 *
	 *	@param byte Байт данных.
	 *	@param status Статус источника данных, True - ошибка.
	 */
	INLINE void checkByteProtocol(uint8_t byte, bool status) {
		// проверка полученного байта по протоколу
		if (status) {
			stepRx = MAX_STEP;
		} else {
			bufRx[stepRx] = byte;

			if (stepRx == 0) {
				// первый синхробайт 0хAA
				if  (byte == 0xAA) {
					stepRx = 1;
				}
			} else if (stepRx == 1) {
				// второй синхробайт 0хАА
				// при этом устанавливается флаг наличия связи
				if (byte == 0xAA) {
					stepRx = 2;
					connect = true;
				} else {
					stepRx = 0;
				}
			} else if (stepRx <= 9) {
				// 4 прямой + инверсный байта команд
				// прямой байт записывается в буфер
				// инверсный сравнивается с ним
				if ((stepRx % 2) == 0) {
					stepRx++;
				} else {
					if ((byte ^ bufRx[stepRx - 1]) == 0xFF) {
						bufRx[stepRx++] = byte;
					} else {
						// ошибка, прямой байт команды не равен инверсному
						stepRx = MAX_STEP;
					}
				}
			} else if (stepRx <= 14) {
				// 5 резервных байт данных
				// crc не считаем т.к. должны быть равны 0
				stepRx = (byte == 0) ? stepRx + 1 : MAX_STEP;
			} else if (stepRx == 15) {
				// проверка контрольной суммы
				if (byte == 0xFC) {
					stepRx = 0;
					checkCommand();
				} else {
					// ошибка контрольной суммы
					stepRx = MAX_STEP;
				}
			}
		}

		// в случае ошибки обработки протокола
		// возвращаемся к поиску синхробайт и устанавливаем ошибку
		if (stepRx >= MAX_STEP) {
			stepRx = 0;
			setError();
		}
	}
};

#endif /* __DR_H_ */
